# 礼尚记 (LiShangJi) 技术设计文档

> 版本：v1.0  
> 最后更新：2026-02-06  
> 状态：可用于开发

---

## 目录

1. [项目概览](#1-项目概览)
2. [技术栈与环境](#2-技术栈与环境)
3. [项目架构设计](#3-项目架构设计)
4. [项目目录结构](#4-项目目录结构)
5. [数据模型设计](#5-数据模型设计)
6. [CloudKit 同步策略](#6-cloudkit-同步策略)
7. [核心功能模块技术方案](#7-核心功能模块技术方案)
8. [安全与隐私](#8-安全与隐私)
9. [iOS 原生特性集成](#9-ios-原生特性集成)
10. [第三方依赖](#10-第三方依赖)
11. [开发阶段规划](#11-开发阶段规划)
12. [附录：关键技术风险与应对](#12-附录关键技术风险与应对)

---

## 1. 项目概览

### 1.1 产品定位

"礼尚记"是一款面向中国用户的 iOS 人情往来记账 App，核心解决"人情遗忘"和"回礼对账"问题。定价 ¥9.9 买断制，强调本地优先（Local-First）架构和极致隐私保护。

### 1.2 核心技术目标

| 目标 | 说明 |
|------|------|
| 零服务器成本 | 完全依赖 iCloud/CloudKit，开发者不自建后端 |
| 离线可用 | 所有核心功能本地运行，无需联网 |
| 隐私至上 | 数据仅存于用户设备与 iCloud，开发者无法访问 |
| 原生体验 | 深度集成 iOS 系统能力（Widget、Siri、Dynamic Island） |
| 高性能 | 利用 SwiftData 的懒加载和 Core ML 的本地推理 |

### 1.3 支持平台

| 平台 | 最低版本 | 说明 |
|------|----------|------|
| iPhone | iOS 17.0 | 主要使用场景 |
| iPad | iPadOS 17.0 | 大屏适配，支持分栏布局 |

> 注：项目 Xcode 配置的 Deployment Target 为 iOS 26.0，但建议根据实际市场需要调整为 iOS 17.0 以覆盖更多用户。

---

## 2. 技术栈与环境

### 2.1 开发环境

| 组件 | 版本/工具 |
|------|-----------|
| IDE | Xcode 16+ |
| 语言 | Swift 5.10+ (Swift 6 ready) |
| 最低部署目标 | iOS 17.0 |
| 包管理 | Swift Package Manager (SPM) |
| 版本管理 | Git |

### 2.2 技术栈总览

| 层级 | 技术选型 | 说明 |
|------|----------|------|
| UI 框架 | SwiftUI | 声明式 UI，跨设备适配 |
| 数据持久化 | SwiftData | Swift 原生 ORM，替代 Core Data |
| 云同步 | CloudKit (via SwiftData) | 自动镜像到 iCloud |
| OCR 引擎 | Vision Framework | 离线文字识别，保护隐私 |
| 语音识别 | Speech Framework | 离线语音转文字 |
| 图表 | Swift Charts | Apple 原生图表框架 |
| 本地认证 | LocalAuthentication | FaceID/TouchID |
| 日历 | EventKit + 自研农历算法 | 农历与公历互转 |
| 通讯录 | Contacts Framework | 联系人关联 |
| 定位 | Core Location | 获取城市信息用于礼俗建议 |
| 小组件 | WidgetKit | 桌面小组件 |
| Siri 集成 | AppIntents | Siri 快捷指令 |
| Excel 导出 | CoreXLSX (SPM) | 生成 .xlsx 文件 |
| PDF 生成 | PDFKit | 电子借条 PDF |
| 触觉反馈 | UIFeedbackGenerator | Taptic Engine |

---

## 3. 项目架构设计

### 3.1 架构模式：MVVM + Clean Architecture

采用 **MVVM (Model-View-ViewModel)** 作为表现层架构，结合 **Clean Architecture** 的分层思想，按功能模块（Feature Module）组织代码。

```
┌──────────────────────────────────────────────────┐
│                   View Layer                      │
│  (SwiftUI Views, 负责 UI 渲染和用户交互)           │
├──────────────────────────────────────────────────┤
│                ViewModel Layer                    │
│  (@Observable, 持有状态和业务逻辑调度)              │
├──────────────────────────────────────────────────┤
│                 Service Layer                     │
│  (业务逻辑: OCR、语音、导出、农历、礼俗等)          │
├──────────────────────────────────────────────────┤
│               Repository Layer                    │
│  (数据访问抽象: CRUD、查询、聚合计算)               │
├──────────────────────────────────────────────────┤
│                  Data Layer                       │
│  (SwiftData Models + CloudKit 自动同步)            │
└──────────────────────────────────────────────────┘
```

### 3.2 各层职责

| 层级 | 职责 | 关键规则 |
|------|------|----------|
| **View** | 纯 UI 渲染，绑定 ViewModel 状态 | 不包含业务逻辑，不直接访问 ModelContext |
| **ViewModel** | 持有 UI 状态，调度 Service 和 Repository | 使用 `@Observable` 宏，不使用 `@Published` |
| **Service** | 封装具体业务逻辑（OCR、导出、农历等） | 可注入、可测试、单一职责 |
| **Repository** | 数据访问抽象，封装 SwiftData 查询 | 隐藏数据层细节，提供 Protocol 接口 |
| **Model** | SwiftData `@Model` 定义，纯数据 | 遵循 CloudKit 约束（默认值、可选关系） |

### 3.3 依赖注入

使用 SwiftUI 原生的 `@Environment` 机制进行依赖注入：

```swift
// 定义 Environment Key
struct GiftBookRepositoryKey: EnvironmentKey {
    static let defaultValue: GiftBookRepositoryProtocol = GiftBookRepository()
}

extension EnvironmentValues {
    var giftBookRepository: GiftBookRepositoryProtocol {
        get { self[GiftBookRepositoryKey.self] }
        set { self[GiftBookRepositoryKey.self] = newValue }
    }
}
```

对于 Service 层，通过 ViewModel 的初始化器注入，便于单元测试时 Mock。

### 3.4 数据流

```
用户操作 → View → ViewModel (处理逻辑) → Repository/Service → SwiftData
                                                                  ↓
                                                            CloudKit 自动同步
                                                                  ↓
UI 更新 ← View ← ViewModel ← @Query / 手动 fetch ← SwiftData 变更通知
```

---

## 4. 项目目录结构

```
LiShangJi/
├── LiShangJi/
│   ├── App/
│   │   ├── LiShangJiApp.swift              # App 入口
│   │   └── AppConstants.swift              # 全局常量
│   │
│   ├── Models/                             # SwiftData 数据模型
│   │   ├── GiftBook.swift                  # 账本模型
│   │   ├── GiftRecord.swift                # 礼金记录模型
│   │   ├── Contact.swift                   # 联系人模型
│   │   ├── GiftEvent.swift                 # 事件模型
│   │   └── Enums/
│   │       ├── GiftDirection.swift         # 收/送方向枚举
│   │       ├── RelationType.swift          # 关系类型枚举
│   │       ├── EventCategory.swift         # 事件类别枚举
│   │       └── RecordType.swift            # 赠与/借贷类型枚举
│   │
│   ├── Repositories/                       # 数据访问层
│   │   ├── Protocols/
│   │   │   ├── GiftBookRepositoryProtocol.swift
│   │   │   ├── GiftRecordRepositoryProtocol.swift
│   │   │   └── ContactRepositoryProtocol.swift
│   │   ├── GiftBookRepository.swift
│   │   ├── GiftRecordRepository.swift
│   │   └── ContactRepository.swift
│   │
│   ├── Services/                           # 业务服务层
│   │   ├── OCRService.swift                # OCR 识别服务
│   │   ├── SpeechService.swift             # 语音识别服务
│   │   ├── ExportService.swift             # 数据导出服务（Excel/CSV/PDF）
│   │   ├── LunarCalendarService.swift      # 农历服务
│   │   ├── EtiquetteService.swift          # 礼俗知识服务
│   │   ├── ContactSyncService.swift        # 通讯录同步服务
│   │   ├── BackupService.swift             # 本地快照备份服务
│   │   ├── BiometricAuthService.swift      # 生物识别认证服务
│   │   └── NotificationService.swift       # 本地通知服务
│   │
│   ├── Features/                           # 功能模块（按 Feature 组织）
│   │   ├── Home/                           # 首页（仪表盘）
│   │   │   ├── HomeView.swift
│   │   │   ├── HomeViewModel.swift
│   │   │   └── Components/
│   │   │       ├── DashboardCardView.swift
│   │   │       ├── RecentRecordRow.swift
│   │   │       └── QuickEntryButton.swift
│   │   │
│   │   ├── GiftBook/                       # 账本模块
│   │   │   ├── GiftBookListView.swift
│   │   │   ├── GiftBookDetailView.swift
│   │   │   ├── GiftBookFormView.swift
│   │   │   └── GiftBookViewModel.swift
│   │   │
│   │   ├── Record/                         # 记录模块
│   │   │   ├── RecordEntryView.swift       # 极速录入
│   │   │   ├── RecordDetailView.swift
│   │   │   ├── RecordListView.swift
│   │   │   ├── RecordViewModel.swift
│   │   │   └── Components/
│   │   │       ├── AmountKeypadView.swift   # 大金额键盘
│   │   │       ├── OCRScannerView.swift     # OCR 扫描界面
│   │   │       └── VoiceInputView.swift     # 语音输入界面
│   │   │
│   │   ├── Contacts/                       # 联系人模块
│   │   │   ├── ContactListView.swift
│   │   │   ├── ContactDetailView.swift
│   │   │   ├── ContactViewModel.swift
│   │   │   └── Components/
│   │   │       └── ContactBalanceView.swift # 人情差额展示
│   │   │
│   │   ├── Statistics/                     # 统计分析模块
│   │   │   ├── StatisticsView.swift
│   │   │   ├── StatisticsViewModel.swift
│   │   │   └── Components/
│   │   │       ├── TrendChartView.swift     # 收支趋势图
│   │   │       ├── RelationHeatmapView.swift # 关系热力图
│   │   │       └── AnnualReportView.swift   # 年度报告
│   │   │
│   │   ├── Etiquette/                      # 礼俗助手模块
│   │   │   ├── EtiquetteView.swift
│   │   │   ├── EtiquetteViewModel.swift
│   │   │   └── EtiquetteData/
│   │   │       └── RegionalEtiquette.json  # 各地区礼俗数据
│   │   │
│   │   └── Settings/                       # 设置模块
│   │       ├── SettingsView.swift
│   │       ├── SettingsViewModel.swift
│   │       ├── PrivacySettingsView.swift
│   │       ├── ExportSettingsView.swift
│   │       └── AboutView.swift
│   │
│   ├── Shared/                             # 共享组件
│   │   ├── Components/                     # 通用 UI 组件
│   │   │   ├── LSJCard.swift               # 卡片组件
│   │   │   ├── LSJButton.swift             # 按钮组件
│   │   │   ├── LSJTextField.swift          # 输入框组件
│   │   │   ├── LSJTag.swift                # 标签组件
│   │   │   ├── LSJToast.swift              # Toast 提示组件
│   │   │   ├── LSJEmptyStateView.swift     # 空状态组件
│   │   │   └── LSJBlurOverlay.swift        # 隐私模糊遮罩
│   │   ├── Extensions/                     # Swift 扩展
│   │   │   ├── Color+Theme.swift           # 主题颜色扩展
│   │   │   ├── Date+Lunar.swift            # 农历日期扩展
│   │   │   ├── Double+Currency.swift       # 金额格式化扩展
│   │   │   └── View+Haptics.swift          # 触觉反馈扩展
│   │   ├── Modifiers/                      # 自定义 ViewModifier
│   │   │   ├── CardModifier.swift
│   │   │   └── ShakeModifier.swift
│   │   └── Utilities/
│   │       ├── HapticManager.swift         # 触觉反馈管理器
│   │       └── NumberFormatter+Gift.swift
│   │
│   ├── Navigation/                         # 导航管理
│   │   ├── MainTabView.swift               # 主 Tab 导航
│   │   └── NavigationRouter.swift          # 路由管理
│   │
│   ├── Resources/                          # 资源文件
│   │   ├── Assets.xcassets/                # 图片与颜色资源
│   │   ├── Localizable.strings             # 本地化字符串
│   │   └── EtiquetteDatabase/              # 礼俗知识库 JSON
│   │       ├── provinces.json
│   │       └── customs.json
│   │
│   ├── Info.plist
│   └── LiShangJi.entitlements
│
├── LiShangJiWidget/                        # 桌面小组件
│   ├── LiShangJiWidget.swift
│   ├── LiShangJiWidgetBundle.swift
│   └── Views/
│       ├── SmallWidgetView.swift
│       └── MediumWidgetView.swift
│
├── LiShangJiIntents/                       # Siri 快捷指令
│   └── RecordGiftIntent.swift
│
├── LiShangJiTests/                         # 单元测试
│   ├── Repositories/
│   ├── Services/
│   └── ViewModels/
│
└── LiShangJiUITests/                       # UI 测试
```

---

## 5. 数据模型设计

### 5.1 ER 关系图

```
┌─────────────┐       1:N       ┌──────────────┐
│  GiftBook   │ ◄──────────────►│  GiftRecord  │
│  (账本)      │                 │  (礼金记录)   │
└─────────────┘                 └──────┬───────┘
                                       │ N:1
                                       ▼
                                ┌──────────────┐
                                │   Contact    │
                                │   (联系人)    │
                                └──────┬───────┘
                                       │ N:1 (可选)
                                       ▼
                                ┌──────────────┐
                                │  GiftEvent   │
                                │   (事件)      │
                                └──────────────┘
```

### 5.2 模型定义

> **CloudKit 约束提醒：**
> - 所有非可选属性 **必须在声明时设置默认值**
> - 所有关系属性 **必须声明为可选类型**
> - 所有 `@Relationship` **必须设置 `inverse`**
> - **禁止使用** `@Attribute(.unique)`

#### 5.2.1 GiftBook（账本）

```swift
import Foundation
import SwiftData

@Model
final class GiftBook {
    // MARK: - 基本属性
    var id: UUID = UUID()
    var name: String = ""                        // 账本名称，如"我的婚礼"、"2026春节"
    var icon: String = "book.closed.fill"         // SF Symbol 名称
    var colorHex: String = "#C04851"              // 主题色 HEX
    var note: String = ""                         // 账本备注
    var createdAt: Date = Date()
    var updatedAt: Date = Date()
    var isArchived: Bool = false                  // 是否归档
    var sortOrder: Int = 0                        // 排序权重

    // MARK: - 关系
    @Relationship(deleteRule: .cascade, inverse: \GiftRecord.book)
    var records: [GiftRecord]? = []

    init(name: String, icon: String = "book.closed.fill", colorHex: String = "#C04851") {
        self.id = UUID()
        self.name = name
        self.icon = icon
        self.colorHex = colorHex
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}
```

#### 5.2.2 GiftRecord（礼金记录）

```swift
@Model
final class GiftRecord {
    // MARK: - 基本属性
    var id: UUID = UUID()
    var amount: Double = 0.0                      // 金额
    var direction: String = "sent"                // "sent"(送出) / "received"(收到)
    var recordType: String = "gift"               // "gift"(赠与) / "loan"(借贷)
    var eventName: String = ""                    // 事件名称，如"张三婚礼"
    var eventCategory: String = "wedding"         // 事件类别
    var eventDate: Date = Date()                  // 事件日期
    var note: String = ""                         // 备注
    var createdAt: Date = Date()
    var updatedAt: Date = Date()

    // MARK: - OCR/语音来源标记
    var source: String = "manual"                 // "manual" / "ocr" / "voice"
    var ocrImageData: Data = Data()               // OCR 原图（压缩后存储，可选使用）

    // MARK: - 借贷专用字段
    var isLoanSettled: Bool = false                // 借贷是否已结清
    var loanDueDate: Date = Date()                // 借贷到期日

    // MARK: - 关系
    var book: GiftBook?                           // 所属账本
    var contact: Contact?                         // 关联联系人

    init(amount: Double, direction: String, eventName: String) {
        self.id = UUID()
        self.amount = amount
        self.direction = direction
        self.eventName = eventName
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}
```

#### 5.2.3 Contact（联系人）

```swift
@Model
final class Contact {
    // MARK: - 基本属性
    var id: UUID = UUID()
    var name: String = ""                          // 姓名
    var phone: String = ""                         // 电话号码
    var relation: String = "other"                 // 关系类型
    var group: String = ""                         // 分组（亲戚/同事/同学/朋友）
    var note: String = ""                          // 备注
    var avatarSystemName: String = "person.circle.fill" // SF Symbol 头像
    var createdAt: Date = Date()
    var updatedAt: Date = Date()

    // MARK: - 农历生日
    var lunarBirthday: String = ""                 // 农历生日字符串，格式: "腊月-廿五"
    var solarBirthday: Date = Date()               // 公历生日
    var hasBirthday: Bool = false                  // 是否设置了生日

    // MARK: - 系统通讯录关联
    var systemContactID: String = ""               // CNContact identifier

    // MARK: - 关系
    @Relationship(deleteRule: .nullify, inverse: \GiftRecord.contact)
    var records: [GiftRecord]? = []

    init(name: String, relation: String = "other") {
        self.id = UUID()
        self.name = name
        self.relation = relation
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}
```

#### 5.2.4 GiftEvent（事件模板）

```swift
@Model
final class GiftEvent {
    // MARK: - 基本属性
    var id: UUID = UUID()
    var name: String = ""                          // 事件名称
    var category: String = "wedding"               // 事件类别
    var icon: String = "heart.fill"                // SF Symbol
    var isBuiltIn: Bool = false                    // 是否为系统内置事件
    var sortOrder: Int = 0
    var createdAt: Date = Date()

    init(name: String, category: String, icon: String, isBuiltIn: Bool = false) {
        self.id = UUID()
        self.name = name
        self.category = category
        self.icon = icon
        self.isBuiltIn = isBuiltIn
    }
}
```

### 5.3 枚举定义

由于 CloudKit 不支持自定义枚举的直接存储，所有枚举在模型中以 `String` 形式存储，枚举仅在业务逻辑层使用。

```swift
// MARK: - 收送方向
enum GiftDirection: String, CaseIterable, Codable {
    case sent = "sent"           // 送出
    case received = "received"   // 收到

    var displayName: String {
        switch self {
        case .sent: return "送出"
        case .received: return "收到"
        }
    }
}

// MARK: - 事件类别
enum EventCategory: String, CaseIterable, Codable {
    case wedding = "wedding"             // 婚礼
    case babyBorn = "baby_born"          // 新生儿
    case fullMoon = "full_moon"          // 满月酒
    case firstBirthday = "first_birthday" // 周岁
    case birthday = "birthday"           // 生日
    case funeral = "funeral"             // 丧事
    case housewarming = "housewarming"   // 乔迁
    case graduation = "graduation"       // 升学
    case promotion = "promotion"         // 升职
    case springFestival = "spring_festival" // 春节
    case midAutumn = "mid_autumn"        // 中秋
    case dragonBoat = "dragon_boat"      // 端午
    case other = "other"                 // 其他

    var displayName: String {
        switch self {
        case .wedding: return "婚礼"
        case .babyBorn: return "新生儿"
        case .fullMoon: return "满月酒"
        case .firstBirthday: return "周岁"
        case .birthday: return "生日"
        case .funeral: return "丧事"
        case .housewarming: return "乔迁"
        case .graduation: return "升学"
        case .promotion: return "升职"
        case .springFestival: return "春节"
        case .midAutumn: return "中秋"
        case .dragonBoat: return "端午"
        case .other: return "其他"
        }
    }

    var icon: String {
        switch self {
        case .wedding: return "heart.fill"
        case .babyBorn: return "figure.and.child.holdinghands"
        case .fullMoon: return "moon.fill"
        case .firstBirthday: return "birthday.cake.fill"
        case .birthday: return "gift.fill"
        case .funeral: return "leaf.fill"
        case .housewarming: return "house.fill"
        case .graduation: return "graduationcap.fill"
        case .promotion: return "star.fill"
        case .springFestival: return "fireworks"
        case .midAutumn: return "moon.haze.fill"
        case .dragonBoat: return "sailboat.fill"
        case .other: return "ellipsis.circle.fill"
        }
    }
}

// MARK: - 关系类型
enum RelationType: String, CaseIterable, Codable {
    case family = "family"           // 亲戚
    case colleague = "colleague"     // 同事
    case classmate = "classmate"     // 同学
    case friend = "friend"           // 朋友
    case neighbor = "neighbor"       // 邻居
    case business = "business"       // 商务
    case other = "other"             // 其他

    var displayName: String {
        switch self {
        case .family: return "亲戚"
        case .colleague: return "同事"
        case .classmate: return "同学"
        case .friend: return "朋友"
        case .neighbor: return "邻居"
        case .business: return "商务"
        case .other: return "其他"
        }
    }
}

// MARK: - 记录类型
enum RecordType: String, CaseIterable, Codable {
    case gift = "gift"       // 赠与（随礼）
    case loan = "loan"       // 借贷

    var displayName: String {
        switch self {
        case .gift: return "随礼"
        case .loan: return "借贷"
        }
    }
}
```

### 5.4 ModelContainer 配置

```swift
import SwiftUI
import SwiftData

@main
struct LiShangJiApp: App {
    var sharedModelContainer: ModelContainer = {
        let schema = Schema([
            GiftBook.self,
            GiftRecord.self,
            Contact.self,
            GiftEvent.self,
        ])

        let modelConfiguration = ModelConfiguration(
            schema: schema,
            isStoredInMemoryOnly: false,
            cloudKitDatabase: .automatic  // 自动启用 CloudKit 同步
        )

        do {
            return try ModelContainer(
                for: schema,
                configurations: [modelConfiguration]
            )
        } catch {
            fatalError("无法创建 ModelContainer: \(error)")
        }
    }()

    var body: some Scene {
        WindowGroup {
            MainTabView()
        }
        .modelContainer(sharedModelContainer)
    }
}
```

---

## 6. CloudKit 同步策略

### 6.1 自动同步机制

SwiftData 配合 CloudKit 的自动同步流程：

```
本地 SwiftData 操作 (Insert/Update/Delete)
        ↓
SwiftData 自动生成 CloudKit Record
        ↓
NSPersistentCloudKitContainer 批量上传
        ↓
其他设备收到 Remote Notification
        ↓
自动拉取变更并合并到本地 SwiftData
```

### 6.2 CloudKit 配置要点

1. **Xcode Capabilities**：
   - 勾选 `iCloud` → `CloudKit`
   - 创建 Container：`iCloud.com.xxl.LiShangJi`
   - 勾选 `Background Modes` → `Remote notifications`

2. **ModelConfiguration 设置**：
   - `cloudKitDatabase: .automatic` — 使用 Private Database
   - 数据仅对用户可见，开发者无法访问

### 6.3 本地快照备份

为防止 CloudKit 同步异常导致数据丢失，实现本地快照机制：

```swift
class BackupService {
    private let fileManager = FileManager.default

    /// 快照保存目录
    private var backupDirectory: URL {
        let documents = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
        return documents.appendingPathComponent("Backups", isDirectory: true)
    }

    /// 创建 JSON 快照
    func createSnapshot(from modelContext: ModelContext) async throws -> URL {
        // 1. 获取所有数据
        let books = try modelContext.fetch(FetchDescriptor<GiftBook>())
        let records = try modelContext.fetch(FetchDescriptor<GiftRecord>())
        let contacts = try modelContext.fetch(FetchDescriptor<Contact>())

        // 2. 转换为可序列化结构
        let snapshot = BackupSnapshot(
            timestamp: Date(),
            version: "1.0",
            books: books.map { $0.toBackupData() },
            records: records.map { $0.toBackupData() },
            contacts: contacts.map { $0.toBackupData() }
        )

        // 3. 序列化并保存
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = .prettyPrinted
        let data = try encoder.encode(snapshot)

        let fileName = "backup_\(ISO8601DateFormatter().string(from: Date())).json"
        let fileURL = backupDirectory.appendingPathComponent(fileName)

        try fileManager.createDirectory(at: backupDirectory, withIntermediateDirectories: true)
        try data.write(to: fileURL)

        // 4. 清理旧快照（保留最近 10 个）
        try cleanOldSnapshots(keepCount: 10)

        return fileURL
    }

    /// 从快照恢复
    func restoreFromSnapshot(_ url: URL, to modelContext: ModelContext) async throws {
        let data = try Data(contentsOf: url)
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        let snapshot = try decoder.decode(BackupSnapshot.self, from: data)

        // 恢复逻辑：先清空再插入
        // ... 具体实现
    }
}
```

### 6.4 冲突解决策略

| 场景 | 策略 | 说明 |
|------|------|------|
| 同一记录在多端修改 | 最后修改优先 | 以 `updatedAt` 较新的版本为准 |
| 云端数据被异常清空 | 本地快照恢复 | 检测到记录数骤降时弹窗提示用户恢复 |
| 网络断开 | 本地正常使用 | 恢复网络后自动同步 |
| 首次安装(换机) | 自动从 iCloud 拉取 | SwiftData + CloudKit 自动完成 |

---

## 7. 核心功能模块技术方案

### 7.1 智能账本管理

#### 多账本 CRUD

```swift
// Repository 协议
protocol GiftBookRepositoryProtocol {
    func fetchAll() throws -> [GiftBook]
    func fetchActive() throws -> [GiftBook]  // 未归档的账本
    func create(name: String, icon: String, colorHex: String) throws -> GiftBook
    func update(_ book: GiftBook) throws
    func archive(_ book: GiftBook) throws
    func delete(_ book: GiftBook) throws
    func totalSent(for book: GiftBook) -> Double
    func totalReceived(for book: GiftBook) -> Double
}

// ViewModel
@Observable
class GiftBookViewModel {
    private let repository: GiftBookRepositoryProtocol
    var books: [GiftBook] = []
    var isLoading = false
    var errorMessage: String?

    init(repository: GiftBookRepositoryProtocol = GiftBookRepository()) {
        self.repository = repository
    }

    func loadBooks() {
        do {
            books = try repository.fetchActive()
        } catch {
            errorMessage = "加载账本失败: \(error.localizedDescription)"
        }
    }
}
```

#### 记录录入流程

```
用户选择录入方式
├── 手动录入 → AmountKeypadView → 填写信息 → 保存
├── OCR 扫描 → OCRScannerView → 识别结果校对 → 批量保存
└── 语音输入 → VoiceInputView → 解析结果确认 → 保存
```

### 7.2 OCR 智能识别

#### 技术方案

使用 Apple 原生 **Vision Framework** 进行文字识别，零成本、离线可用。

```swift
import Vision
import UIKit

class OCRService {
    /// 识别图片中的文字，返回 (姓名, 金额) 键值对
    func recognizeGiftList(from image: UIImage) async throws -> [OCRResult] {
        guard let cgImage = image.cgImage else {
            throw OCRError.invalidImage
        }

        // 1. 创建文字识别请求
        let request = VNRecognizeTextRequest()
        request.recognitionLanguages = ["zh-Hans", "zh-Hant", "en"]
        request.recognitionLevel = .accurate  // 使用精确模式
        request.usesLanguageCorrection = true

        // 2. 执行识别
        let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        try handler.perform([request])

        // 3. 提取结果
        guard let observations = request.results else {
            return []
        }

        let recognizedStrings = observations.compactMap { observation in
            observation.topCandidates(1).first?.string
        }

        // 4. 解析姓名-金额对
        return parseGiftEntries(from: recognizedStrings)
    }

    /// 解析文本行，提取姓名和金额
    private func parseGiftEntries(from lines: [String]) -> [OCRResult] {
        var results: [OCRResult] = []

        for line in lines {
            // 匹配模式：姓名 + 金额（支持中文数字和阿拉伯数字）
            // 例如："张三 888" 或 "李四 壹仟元"
            let pattern = #"([\u4e00-\u9fa5]{2,4})\s*[：:]*\s*(\d+[\d,.]*|\S*[百千万]+\S*)"#

            if let regex = try? NSRegularExpression(pattern: pattern),
               let match = regex.firstMatch(in: line, range: NSRange(line.startIndex..., in: line)) {

                let nameRange = Range(match.range(at: 1), in: line)!
                let amountRange = Range(match.range(at: 2), in: line)!

                let name = String(line[nameRange])
                let amountStr = String(line[amountRange])
                let amount = parseAmount(amountStr)

                results.append(OCRResult(
                    name: name,
                    amount: amount,
                    rawText: line,
                    confidence: 0.0  // 由 Vision 框架返回
                ))
            }
        }

        return results
    }

    /// 解析金额字符串（支持中文大写数字）
    private func parseAmount(_ str: String) -> Double {
        // 先尝试直接转换阿拉伯数字
        let cleaned = str.replacingOccurrences(of: ",", with: "")
        if let amount = Double(cleaned) {
            return amount
        }

        // 中文大写数字转换
        return chineseAmountToDouble(str)
    }

    private func chineseAmountToDouble(_ str: String) -> Double {
        // 中文数字映射表
        let digitMap: [Character: Double] = [
            "零": 0, "壹": 1, "贰": 2, "叁": 3, "肆": 4,
            "伍": 5, "陆": 6, "柒": 7, "捌": 8, "玖": 9,
            "一": 1, "二": 2, "三": 3, "四": 4, "五": 5,
            "六": 6, "七": 7, "八": 8, "九": 9,
        ]
        let unitMap: [Character: Double] = [
            "拾": 10, "佰": 100, "仟": 1000, "万": 10000,
            "十": 10, "百": 100, "千": 1000,
        ]

        var result: Double = 0
        var current: Double = 0

        for char in str {
            if let digit = digitMap[char] {
                current = digit
            } else if let unit = unitMap[char] {
                if current == 0 { current = 1 }
                result += current * unit
                current = 0
            }
        }

        return result + current
    }
}

struct OCRResult {
    let name: String
    let amount: Double
    let rawText: String
    let confidence: Float
}
```

#### OCR 校对界面

识别完成后，展示原图切片与识别结果的对照界面，用户可快速修正错误：

```
┌────────────────────────────────┐
│  [原图切片区域]                  │
│  ┌──────────────────────────┐  │
│  │ 张三   888               │  │
│  └──────────────────────────┘  │
│  姓名: [张三    ]  金额: [888]  │  ← 可编辑
│  ───────────────────────────── │
│  [原图切片区域]                  │
│  ┌──────────────────────────┐  │
│  │ 李四   1000              │  │
│  └──────────────────────────┘  │
│  姓名: [李四    ]  金额: [1000] │  ← 可编辑
│  ───────────────────────────── │
│         [全部确认并保存]         │
└────────────────────────────────┘
```

### 7.3 语音记账

#### 技术方案

使用 **Speech Framework** 进行本地语音识别，结合自然语言解析提取记录信息。

```swift
import Speech
import AVFoundation

class SpeechService: NSObject {
    private var audioEngine = AVAudioEngine()
    private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest?
    private var recognitionTask: SFSpeechRecognitionTask?
    private let speechRecognizer = SFSpeechRecognizer(locale: Locale(identifier: "zh-CN"))

    /// 请求语音识别权限
    func requestAuthorization() async -> Bool {
        await withCheckedContinuation { continuation in
            SFSpeechRecognizer.requestAuthorization { status in
                continuation.resume(returning: status == .authorized)
            }
        }
    }

    /// 开始录音识别
    func startRecording(onResult: @escaping (String) -> Void) throws {
        // 取消之前的任务
        recognitionTask?.cancel()
        recognitionTask = nil

        let audioSession = AVAudioSession.sharedInstance()
        try audioSession.setCategory(.record, mode: .measurement, options: .duckOthers)
        try audioSession.setActive(true, options: .notifyOthersOnDeactivation)

        recognitionRequest = SFSpeechAudioBufferRecognitionRequest()
        guard let recognitionRequest = recognitionRequest else { return }
        recognitionRequest.shouldReportPartialResults = true

        // 优先使用离线识别
        if #available(iOS 13, *) {
            recognitionRequest.requiresOnDeviceRecognition = true
        }

        recognitionTask = speechRecognizer?.recognitionTask(with: recognitionRequest) { result, error in
            if let result = result {
                let text = result.bestTranscription.formattedString
                onResult(text)
            }
        }

        let inputNode = audioEngine.inputNode
        let recordingFormat = inputNode.outputFormat(forBus: 0)
        inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { buffer, _ in
            self.recognitionRequest?.append(buffer)
        }

        audioEngine.prepare()
        try audioEngine.start()
    }

    /// 停止录音
    func stopRecording() {
        audioEngine.stop()
        audioEngine.inputNode.removeTap(onBus: 0)
        recognitionRequest?.endAudio()
    }

    /// 解析语音文本，提取记录信息
    /// 支持格式："张三结婚随礼一千元"、"送李四八百八十八"
    func parseVoiceInput(_ text: String) -> VoiceParseResult? {
        // 正则匹配：姓名 + 事件 + 金额
        // ... 自然语言解析逻辑
        return nil // 具体实现
    }
}

struct VoiceParseResult {
    var contactName: String
    var amount: Double
    var eventName: String?
    var direction: GiftDirection
}
```

### 7.4 通讯录关联

```swift
import Contacts

class ContactSyncService {
    private let store = CNContactStore()

    /// 请求通讯录访问权限
    func requestAccess() async -> Bool {
        do {
            return try await store.requestAccess(for: .contacts)
        } catch {
            return false
        }
    }

    /// 搜索匹配的系统联系人
    func searchSystemContacts(name: String) throws -> [CNContact] {
        let predicate = CNContact.predicateForContacts(matchingName: name)
        let keysToFetch: [CNKeyDescriptor] = [
            CNContactGivenNameKey as CNKeyDescriptor,
            CNContactFamilyNameKey as CNKeyDescriptor,
            CNContactPhoneNumbersKey as CNKeyDescriptor,
            CNContactIdentifierKey as CNKeyDescriptor,
        ]
        return try store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)
    }

    /// 根据输入文本模糊匹配联系人（用于录入时的自动联想）
    func fuzzyMatch(query: String, in contacts: [Contact]) -> [Contact] {
        guard !query.isEmpty else { return [] }
        return contacts.filter { contact in
            contact.name.localizedCaseInsensitiveContains(query)
        }
    }
}
```

### 7.5 数据导出

#### Excel 导出 (CoreXLSX)

```swift
import CoreXLSX

class ExportService {
    /// 导出账本为 Excel 文件
    func exportToExcel(book: GiftBook, records: [GiftRecord]) throws -> URL {
        // 使用 CoreXLSX 创建工作簿
        let tempURL = FileManager.default.temporaryDirectory
            .appendingPathComponent("\(book.name)_\(Date().formatted(.dateTime)).xlsx")

        // 创建表头
        // 列：序号 | 姓名 | 关系 | 金额 | 收/送 | 事件 | 日期 | 备注
        // ... 具体实现

        return tempURL
    }

    /// 导出为 CSV
    func exportToCSV(book: GiftBook, records: [GiftRecord]) throws -> URL {
        var csv = "序号,姓名,关系,金额,收/送,事件,日期,备注\n"

        for (index, record) in records.enumerated() {
            let direction = record.direction == "sent" ? "送出" : "收到"
            let name = record.contact?.name ?? "未知"
            let relation = record.contact?.relation ?? ""
            let dateStr = record.eventDate.formatted(date: .numeric, time: .omitted)

            csv += "\(index + 1),\(name),\(relation),\(record.amount),\(direction),"
            csv += "\(record.eventName),\(dateStr),\(record.note)\n"
        }

        let tempURL = FileManager.default.temporaryDirectory
            .appendingPathComponent("\(book.name).csv")
        try csv.write(to: tempURL, atomically: true, encoding: .utf8)
        return tempURL
    }

    /// 生成电子礼单长图
    func exportToImage(book: GiftBook, records: [GiftRecord]) -> UIImage? {
        // 使用 UIGraphicsImageRenderer 绘制长图
        // 包含：标题、日期、收支统计、详细列表
        // ... 具体实现
        return nil
    }

    /// 生成电子借条 PDF
    func generateLoanPDF(record: GiftRecord) throws -> URL {
        let renderer = UIGraphicsPDFRenderer(bounds: CGRect(x: 0, y: 0, width: 595, height: 842)) // A4
        let tempURL = FileManager.default.temporaryDirectory
            .appendingPathComponent("借条_\(record.id).pdf")

        try renderer.writePDF(to: tempURL) { context in
            context.beginPage()
            // 绘制借条模板
            // 包含：标题、借贷双方、金额、日期、用途、签名区
            // ... 具体实现
        }

        return tempURL
    }
}
```

### 7.6 农历计算服务

```swift
class LunarCalendarService {
    // 农历数据表（1900-2100年）
    // 每年用一个 Int 编码：
    // - 低 12 位表示每月大小月（1=30天，0=29天）
    // - 第 13-16 位表示闰月月份（0=无闰月）
    // - 第 17 位表示闰月大小月
    private static let lunarInfo: [Int] = [
        0x04bd8, 0x04ae0, 0x0a570, 0x054d5, 0x0d260,
        0x0d950, 0x16554, 0x056a0, 0x09ad0, 0x055d2,
        // ... 完整数据表（1900-2100年共201项）
    ]

    /// 公历转农历
    func solarToLunar(date: Date) -> LunarDate {
        // 算法实现：基于 lunarInfo 数据表
        // 计算从 1900-01-31（农历正月初一）到目标日期的天数差
        // 逐年逐月扣减得到农历年月日
        // ... 具体实现
        return LunarDate(year: 2026, month: 1, day: 1, isLeapMonth: false)
    }

    /// 农历转公历
    func lunarToSolar(lunarDate: LunarDate) -> Date {
        // 反向计算
        // ... 具体实现
        return Date()
    }

    /// 获取下一个农历生日的公历日期（用于提醒）
    func nextLunarBirthday(lunarMonth: Int, lunarDay: Int) -> Date {
        // 从当前日期开始，计算下一个匹配的农历日期
        // ... 具体实现
        return Date()
    }

    /// 判断是否为重要节日
    func isImportantFestival(date: Date) -> Festival? {
        let lunar = solarToLunar(date: date)

        // 春节：正月初一
        if lunar.month == 1 && lunar.day == 1 {
            return .springFestival
        }
        // 端午：五月初五
        if lunar.month == 5 && lunar.day == 5 {
            return .dragonBoat
        }
        // 中秋：八月十五
        if lunar.month == 8 && lunar.day == 15 {
            return .midAutumn
        }

        return nil
    }
}

struct LunarDate {
    let year: Int
    let month: Int
    let day: Int
    let isLeapMonth: Bool

    /// 农历中文表示
    var displayString: String {
        let monthNames = ["正", "二", "三", "四", "五", "六", "七", "八", "九", "十", "冬", "腊"]
        let dayNames = [
            "初一", "初二", "初三", "初四", "初五", "初六", "初七", "初八", "初九", "初十",
            "十一", "十二", "十三", "十四", "十五", "十六", "十七", "十八", "十九", "二十",
            "廿一", "廿二", "廿三", "廿四", "廿五", "廿六", "廿七", "廿八", "廿九", "三十"
        ]
        let prefix = isLeapMonth ? "闰" : ""
        return "\(prefix)\(monthNames[month - 1])月\(dayNames[day - 1])"
    }
}

enum Festival: String {
    case springFestival = "春节"
    case dragonBoat = "端午节"
    case midAutumn = "中秋节"
}
```

### 7.7 区域礼俗助手

#### 数据结构

礼俗数据以 JSON 文件形式内置于 App Bundle 中：

```json
{
  "provinces": [
    {
      "name": "江苏",
      "cities": [
        {
          "name": "苏州",
          "customs": [
            {
              "event": "wedding",
              "minAmount": 800,
              "maxAmount": 1200,
              "avgAmount": 1000,
              "tips": [
                "讲究'好事成双'，金额尾数避免单数",
                "部分地区有收红包返还部分金额（回礼）的习俗",
                "同事一般800-1000元，亲近的朋友1000-2000元"
              ],
              "taboos": [
                "避免金额含数字4",
                "避免送伞（谐音'散'）"
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

#### 服务实现

```swift
import CoreLocation

class EtiquetteService {
    private var etiquetteData: EtiquetteDatabase?

    init() {
        loadEtiquetteData()
    }

    private func loadEtiquetteData() {
        guard let url = Bundle.main.url(forResource: "customs", withExtension: "json"),
              let data = try? Data(contentsOf: url) else { return }
        etiquetteData = try? JSONDecoder().decode(EtiquetteDatabase.self, from: data)
    }

    /// 根据城市和事件类型获取礼俗建议
    func getSuggestion(city: String, eventCategory: EventCategory) -> EtiquetteSuggestion? {
        guard let province = etiquetteData?.provinces.first(where: { province in
            province.cities.contains { $0.name == city }
        }),
        let cityData = province.cities.first(where: { $0.name == city }),
        let custom = cityData.customs.first(where: { $0.event == eventCategory.rawValue })
        else { return nil }

        return EtiquetteSuggestion(
            city: city,
            event: eventCategory,
            minAmount: custom.minAmount,
            maxAmount: custom.maxAmount,
            avgAmount: custom.avgAmount,
            tips: custom.tips,
            taboos: custom.taboos,
            recommendedAmounts: generateRecommendedAmounts(
                min: custom.minAmount,
                max: custom.maxAmount
            )
        )
    }

    /// 生成推荐金额列表（吉利数字）
    private func generateRecommendedAmounts(min: Double, max: Double) -> [Double] {
        let luckyAmounts: [Double] = [
            200, 300, 500, 600, 666, 800, 888,
            1000, 1200, 1314, 1600, 1666, 1888,
            2000, 2600, 2888, 3000, 5000, 6000,
            6600, 6666, 8000, 8800, 8888, 10000
        ]
        return luckyAmounts.filter { $0 >= min && $0 <= max * 1.5 }
    }
}

struct EtiquetteSuggestion {
    let city: String
    let event: EventCategory
    let minAmount: Double
    let maxAmount: Double
    let avgAmount: Double
    let tips: [String]
    let taboos: [String]
    let recommendedAmounts: [Double]
}
```

### 7.8 统计分析

使用 **Swift Charts** 实现数据可视化：

```swift
import Charts
import SwiftUI

// MARK: - 收支趋势图
struct TrendChartView: View {
    let data: [MonthlyTrend]

    var body: some View {
        Chart(data) { item in
            BarMark(
                x: .value("月份", item.month),
                y: .value("金额", item.amount)
            )
            .foregroundStyle(by: .value("类型", item.direction))
        }
        .chartForegroundStyleScale([
            "收到": Color.theme.received,   // 朱砂红
            "送出": Color.theme.sent         // 墨灰色
        ])
    }
}

struct MonthlyTrend: Identifiable {
    let id = UUID()
    let month: String
    let amount: Double
    let direction: String
}

// MARK: - 统计聚合查询
class StatisticsViewModel {
    private let modelContext: ModelContext

    /// 计算指定时间范围的收支汇总
    func calculateSummary(from startDate: Date, to endDate: Date) throws -> GiftSummary {
        let predicate = #Predicate<GiftRecord> { record in
            record.eventDate >= startDate && record.eventDate <= endDate
        }
        let records = try modelContext.fetch(FetchDescriptor<GiftRecord>(predicate: predicate))

        let totalSent = records
            .filter { $0.direction == "sent" }
            .reduce(0) { $0 + $1.amount }

        let totalReceived = records
            .filter { $0.direction == "received" }
            .reduce(0) { $0 + $1.amount }

        return GiftSummary(
            totalSent: totalSent,
            totalReceived: totalReceived,
            balance: totalReceived - totalSent,
            recordCount: records.count
        )
    }

    /// 按关系分组统计
    func groupByRelation() throws -> [RelationGroupStat] {
        // ... 按 contact.relation 分组聚合
        return []
    }

    /// 按联系人统计往来差额（识别"僵尸关系"和"核心关系"）
    func contactBalanceRanking() throws -> [ContactBalance] {
        // ... 按联系人聚合，计算差额
        return []
    }
}

struct GiftSummary {
    let totalSent: Double
    let totalReceived: Double
    let balance: Double
    let recordCount: Int
}
```

---

## 8. 安全与隐私

### 8.1 生物识别锁

```swift
import LocalAuthentication

class BiometricAuthService {
    /// 检查设备是否支持生物识别
    func canUseBiometrics() -> Bool {
        let context = LAContext()
        var error: NSError?
        return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error)
    }

    /// 执行生物识别认证
    func authenticate() async -> Bool {
        let context = LAContext()
        context.localizedFallbackTitle = "使用密码"
        context.localizedCancelTitle = "取消"

        do {
            return try await context.evaluatePolicy(
                .deviceOwnerAuthenticationWithBiometrics,
                localizedReason: "解锁礼尚记查看您的人情记录"
            )
        } catch {
            return false
        }
    }
}
```

### 8.2 后台模糊处理

当 App 进入后台时自动模糊界面，防止旁人在 App 切换器中窥屏：

```swift
// 在 App 入口监听生命周期
struct LiShangJiApp: App {
    @Environment(\.scenePhase) private var scenePhase
    @State private var isBlurred = false

    var body: some Scene {
        WindowGroup {
            ZStack {
                MainTabView()
                if isBlurred {
                    BlurOverlayView()
                }
            }
            .onChange(of: scenePhase) { _, newPhase in
                switch newPhase {
                case .background, .inactive:
                    isBlurred = true
                case .active:
                    // 触发生物识别后取消模糊
                    isBlurred = false
                @unknown default:
                    break
                }
            }
        }
    }
}
```

### 8.3 隐私保护原则

| 措施 | 实现方式 |
|------|----------|
| 数据不上传开发者服务器 | 纯 CloudKit Private Database |
| 离线功能可用 | 所有核心功能不依赖网络 |
| OCR 本地处理 | Vision Framework 离线运行 |
| 语音识别本地处理 | Speech Framework 设置 `requiresOnDeviceRecognition = true` |
| 应用锁 | FaceID/TouchID + 密码 fallback |
| 后台隐私 | 自动模糊 + 内容隐藏 |
| 导出文件加密 | 可选对导出的 Excel/CSV 加密压缩 |

---

## 9. iOS 原生特性集成

### 9.1 桌面小组件 (WidgetKit)

提供两种尺寸的小组件：

**Small Widget**：显示本月收支概览
```swift
struct SmallWidgetView: View {
    let entry: GiftWidgetEntry

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text("本月人情")
                .font(.caption)
                .foregroundStyle(.secondary)
            Text("收 ¥\(entry.monthReceived, specifier: "%.0f")")
                .font(.title3.bold())
                .foregroundStyle(Color.theme.primary)
            Text("送 ¥\(entry.monthSent, specifier: "%.0f")")
                .font(.title3.bold())
                .foregroundStyle(Color.theme.textSecondary)
        }
        .containerBackground(for: .widget) {
            Color.theme.background
        }
    }
}
```

**Medium Widget**：显示最近记录列表

### 9.2 Siri 快捷指令 (AppIntents)

```swift
import AppIntents

struct RecordGiftIntent: AppIntent {
    static var title: LocalizedStringResource = "记录人情"
    static var description = IntentDescription("快速记录一笔人情往来")

    @Parameter(title: "联系人姓名")
    var contactName: String

    @Parameter(title: "金额")
    var amount: Double

    @Parameter(title: "类型", default: .sent)
    var direction: GiftDirectionEntity

    func perform() async throws -> some IntentResult & ProvidesDialog {
        // 创建记录逻辑
        let directionText = direction == .sent ? "送出" : "收到"
        return .result(dialog: "已记录：\(directionText) \(contactName) ¥\(amount)")
    }
}

// Siri 对话示例：
// "嘿 Siri，用礼尚记记录张伟结婚随礼1000元"
```

### 9.3 Dynamic Island (ActivityKit)

在婚礼现场等场景，可开启"极速模式"，在 Dynamic Island 展示最新录入的记录和累计金额：

```swift
import ActivityKit

struct GiftRecordingAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        var lastRecordName: String
        var lastRecordAmount: Double
        var totalCount: Int
        var totalAmount: Double
    }

    var bookName: String
}
```

### 9.4 本地通知

```swift
import UserNotifications

class NotificationService {
    /// 设置农历生日提醒
    func scheduleLunarBirthdayReminder(
        contact: Contact,
        solarDate: Date,
        daysBefore: Int = 7
    ) {
        let content = UNMutableNotificationContent()
        content.title = "人情提醒"
        content.body = "距离\(contact.name)的生日还有\(daysBefore)天，建议准备礼物"
        content.sound = .default

        let reminderDate = Calendar.current.date(
            byAdding: .day,
            value: -daysBefore,
            to: solarDate
        )!
        let components = Calendar.current.dateComponents(
            [.year, .month, .day, .hour],
            from: reminderDate
        )
        let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: false)

        let request = UNNotificationRequest(
            identifier: "birthday_\(contact.id)",
            content: content,
            trigger: trigger
        )

        UNUserNotificationCenter.current().add(request)
    }
}
```

---

## 10. 第三方依赖

| 依赖 | 用途 | 引入方式 | 版本 |
|------|------|----------|------|
| [CoreXLSX](https://github.com/CoreOffice/CoreXLSX) | Excel .xlsx 文件生成与读取 | SPM | 最新稳定版 |

> **设计原则**：尽可能使用 Apple 原生框架，最小化第三方依赖，降低维护成本和审核风险。

### SPM 配置

在 Xcode 中通过 `File → Add Package Dependencies` 添加：

```
https://github.com/CoreOffice/CoreXLSX.git
```

---

## 11. 开发阶段规划

### Phase 1：核心基础 (Day 1-15)

| 任务 | 优先级 | 预估工时 |
|------|--------|----------|
| 数据模型定义 (SwiftData) | P0 | 2天 |
| ModelContainer + CloudKit 配置 | P0 | 1天 |
| 账本 CRUD (Repository + ViewModel) | P0 | 2天 |
| 记录录入（手动模式） | P0 | 3天 |
| 联系人管理 | P0 | 2天 |
| 主 Tab 导航框架 | P0 | 1天 |
| 首页仪表盘 | P1 | 2天 |
| 基础 UI 组件库 | P0 | 2天 |

### Phase 2：智能功能 (Day 16-30)

| 任务 | 优先级 | 预估工时 |
|------|--------|----------|
| OCR 识别模块 | P0 | 4天 |
| 语音记账模块 | P1 | 3天 |
| 统计分析（Swift Charts） | P0 | 3天 |
| 通讯录同步 | P1 | 2天 |
| 农历计算服务 | P1 | 2天 |
| 本地通知（生日/节日提醒） | P1 | 1天 |

### Phase 3：增值功能 (Day 31-45)

| 任务 | 优先级 | 预估工时 |
|------|--------|----------|
| 礼俗知识库建设 | P1 | 3天 |
| 数据导出 (Excel/CSV/PDF) | P0 | 3天 |
| 电子借条模板 | P2 | 2天 |
| 生物识别锁 | P0 | 1天 |
| 本地快照备份 | P1 | 2天 |
| 年度人情报告 | P2 | 3天 |

### Phase 4：系统集成 & 上线 (Day 46-60)

| 任务 | 优先级 | 预估工时 |
|------|--------|----------|
| 桌面 Widget 开发 | P1 | 3天 |
| Siri 快捷指令集成 | P1 | 2天 |
| 深色模式完整适配 | P0 | 2天 |
| iPad 大屏适配 | P1 | 2天 |
| 性能优化 & 内存调优 | P0 | 2天 |
| TestFlight 内测 | P0 | 3天 |
| App Store 提交审核 | P0 | 1天 |

---

## 12. 附录：关键技术风险与应对

### 12.1 App Store 审核被拒风险

| 风险点 | 应对策略 |
|--------|----------|
| 被判定为"最小功能"应用 | 开发 Widget、Siri Shortcuts 等原生特性，证明不可被 Web 替代 |
| 被判定为"重复应用" | 在审核备注中强调 OCR、农历算法、LBS 礼俗等差异化功能 |
| 隐私合规 | 仅请求必要权限，提供完整的隐私说明，不收集任何用户数据 |

### 12.2 iCloud 数据同步风险

| 风险点 | 应对策略 |
|--------|----------|
| 同步延迟 | UI 提示"数据同步中"，不依赖实时同步 |
| 数据冲突 | 以 `updatedAt` 最新为准，保留冲突副本 |
| 数据丢失 | 每次启动时创建本地快照，提供手动备份/恢复入口 |

### 12.3 OCR 识别率不足

| 风险点 | 应对策略 |
|--------|----------|
| 潦草手写识别率低 | 提供拍摄引导框，建议分行拍摄 |
| 光线不足影响识别 | 提示用户改善光线条件 |
| 识别结果有误 | 提供便捷的人机校对界面，原图切片与识别结果对照展示 |

---

> **文档结束**  
> 本文档提供了"礼尚记"App 从架构设计到功能实现的完整技术方案，可直接用于开发。
